{"version":3,"file":"caching-when.js","sourceRoot":"","sources":["../src/directives/caching-when.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAEH,OAAO,EAAC,SAAS,EAAa,QAAQ,EAAE,aAAa,EAAC,MAAM,gBAAgB,CAAC;AAc7E,MAAM,UAAU,GAAG,IAAI,OAAO,EAAuB,CAAC;AAyBtD,MAAM,UAAU,WAAW,CACvB,SAAc,EACd,kBAAqC,EACrC,UAAsB;IACxB,IAAI,OAAgB,CAAC;IACrB,IAAI,SAAoB,CAAC;IACzB,IAAI,aAAkB,CAAC;IAEvB,iDAAiD;IACjD,IAAI,OAAO,kBAAkB,KAAK,QAAQ,EAAE;QAC1C,OAAO,GAAG,kBAAkB,CAAC;QAC7B,aAAa,GAAG,SAAS,CAAC;KAC3B;SAAM;QACL,SAAS,GAAG,kBAAkB,CAAC;QAC/B,gEAAgE;QAChE,0CAA0C;QAC1C,aAAa,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;KACpC;IAED,OAAO,SAAS,CAAC,CAAC,UAAoB,EAAE,EAAE;QACxC,IAAI,KAAK,GAAG,UAAU,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAEvC,qDAAqD;QACrD,IAAI,KAAK,KAAK,SAAS,EAAE;YACvB,KAAK,GAAG,EAAC,UAAU,EAAE,IAAI,GAAG,EAAE,EAAC,CAAC;YAChC,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;SACnC;QAED,MAAM,EAAC,aAAa,EAAC,GAAG,KAAK,CAAC;QAC9B,MAAM,SAAS,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QACtD,IAAI,SAAS,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QAEpD,kEAAkE;QAClE,iBAAiB;QACjB,IAAI,CAAC,SAAS,EAAE;YACd,SAAS,GAAG;gBACV,IAAI,EAAE,IAAI,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC;gBACtC,cAAc,EAAE,QAAQ,CAAC,sBAAsB,EAAE;aAClD,CAAC;YACF,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;YAC/C,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;SAC3C;QAED,yEAAyE;QACzE,IAAI,SAA8B,CAAC;QACnC,IAAI,OAAO,EAAE;YACX,SAAS,GAAG,OAAO,CAAC,aAAa,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC;SACvD;aAAM;YACL,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,UAAU,CAAC;SAChD;QAED,2DAA2D;QAC3D,IAAI,aAAa,KAAK,aAAa,EAAE;YACnC,2DAA2D;YAC3D,IAAI,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE;gBACxB,UAAU,CAAC,SAAS,CAAC,UAAW,CAAC,YAAY,CACzC,SAAS,CAAC,cAAc,EAAE,UAAU,CAAC,OAAO,CAAC,CAAC;aACnD;YAED,+DAA+D;YAC/D,IAAI,SAAS,IAAI,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE;gBACrC,aAAa,CACT,SAAS,CAAC,cAAc,EACxB,SAAS,CAAC,IAAI,CAAC,SAAS,EACxB,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;aACzC;SACF;QAED,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAC7D,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;QAExB,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC;IACtC,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, Directive, NodePart, reparentNodes} from '../lit-html.js';\n\nimport {CaseMap, WhenValue} from './when';\n\ninterface ConditionCache {\n  part: NodePart;\n  cacheContainer: DocumentFragment;\n}\n\ninterface PartCache {\n  conditions: Map<any, ConditionCache>;\n  prevCondition?: any;\n}\n\nconst partCaches = new WeakMap<NodePart, PartCache>();\n\n/**\n * Directive for handling conditional logic inside templates. The logic\n * is identical to the regular when directive, with the addition that\n * nodes are cached between switching conditions. This prevents re-creating\n * the nodes of a template each switch, and can help improve render performance.\n *\n * Use this directive only when you need the caching, for example when\n * frequently switching cases or when switching between large dom trees. In\n * other cases use the regular when directive.\n *\n * @param condition the condition to check for truthiness\n * @param caseMap object where keys are cases and values are functions which\n *     return the value to render\n * @param trueValue function that returns the value to render in case of\n *     truthiness\n * @param falseValue function that returns the value to render in case of\n *     falsiness\n */\nexport function cachingWhen(\n    condition: any, trueValue: WhenValue, falseValue?: WhenValue):\n    Directive<NodePart>;\nexport function cachingWhen(\n    condition: any, caseMap: CaseMap): Directive<NodePart>;\nexport function cachingWhen(\n    condition: any,\n    trueValueOrCaseMap: WhenValue|CaseMap,\n    falseValue?: WhenValue): Directive<NodePart> {\n  let caseMap: CaseMap;\n  let trueValue: WhenValue;\n  let nextCondition: any;\n\n  // test whether we are in case or in if/else mode\n  if (typeof trueValueOrCaseMap === 'object') {\n    caseMap = trueValueOrCaseMap;\n    nextCondition = condition;\n  } else {\n    trueValue = trueValueOrCaseMap;\n    // in if or if/else mode, the condition is checked on truthiness\n    // so we coerce the condition to a boolean\n    nextCondition = Boolean(condition);\n  }\n\n  return directive((parentPart: NodePart) => {\n    let cache = partCaches.get(parentPart);\n\n    // create a new PartCache if this is the first render\n    if (cache === undefined) {\n      cache = {conditions: new Map()};\n      partCaches.set(parentPart, cache);\n    }\n\n    const {prevCondition} = cache;\n    const prevCache = cache.conditions.get(prevCondition);\n    let nextCache = cache.conditions.get(nextCondition);\n\n    // create a new ConditionCache if this is the first time rendering\n    // this condition\n    if (!nextCache) {\n      nextCache = {\n        part: new NodePart(parentPart.options),\n        cacheContainer: document.createDocumentFragment(),\n      };\n      cache.conditions.set(nextCondition, nextCache);\n      nextCache.part.appendIntoPart(parentPart);\n    }\n\n    // determine what the next render value is, based on case or if/else mode\n    let nextValue: WhenValue|undefined;\n    if (caseMap) {\n      nextValue = caseMap[nextCondition] || caseMap.default;\n    } else {\n      nextValue = condition ? trueValue : falseValue;\n    }\n\n    // if we switched conditions, swap nodes to/from the cache.\n    if (nextCondition !== prevCondition) {\n      // take next part from the cache, if it was rendered before\n      if (nextCache.part.value) {\n        parentPart.startNode.parentNode!.insertBefore(\n            nextCache.cacheContainer, parentPart.endNode);\n      }\n\n      // move the prev part from the cache, if it was rendered before\n      if (prevCache && prevCache.part.value) {\n        reparentNodes(\n            prevCache.cacheContainer,\n            prevCache.part.startNode,\n            prevCache.part.endNode.nextSibling);\n      }\n    }\n\n    nextCache.part.setValue(nextValue ? nextValue() : undefined);\n    nextCache.part.commit();\n\n    cache.prevCondition = nextCondition;\n  });\n}\n"]}