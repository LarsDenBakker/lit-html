{"version":3,"file":"guard.js","sourceRoot":"","sources":["../src/lib/guard.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAEH,OAAO,EAAC,SAAS,EAAwB,MAAM,YAAY,CAAC;AAE5D,MAAM,mBAAmB,GAAG,IAAI,OAAO,EAAiB,CAAC;AAEzD;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,CAAC,MAAM,KAAK,GAAG,CAAC,UAAe,EAAE,OAAkB,EAAyB,EAAE,CAChF,SAAS,CAAC,CAAC,IAAc,EAAQ,EAAE;IACjC,kCAAkC;IAClC,IAAI,mBAAmB,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,UAAU,EAAE;QAChD,OAAO;KACR;IAED,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC;IACzB,mBAAmB,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;AAC5C,CAAC,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {directive, DirectiveFn, NodePart} from '../core.js';\n\nconst previousExpressions = new WeakMap<NodePart, any>();\n\n/**\n * Creates a guard directive. Prevents any re-render until the identity of the expression\n * changes, for example when a primitive changes value or when an object reference changes.\n *\n * This useful with immutable data patterns, by preventing expensive work until data updates.\n * Example:\n *\n * html`\n *   <div>\n *     ${guard(items, () => items.map(item => html`${item}`))}\n *   </div>\n * `\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param expression the expression to check before re-rendering\n * @param valueFn function which returns the render value\n */\nexport const guard = (expression: any, valueFn: () => any): DirectiveFn<NodePart> =>\n    directive((part: NodePart): void => {\n      // Dirty check previous expression\n      if (previousExpressions.get(part) === expression) {\n        return;\n      }\n\n      part.setValue(valueFn());\n      previousExpressions.set(part, expression);\n    });\n"]}